const type = {
  isString: t => "string" == typeof t || t instanceof String,
  isNumber: t => "number" == typeof t || t instanceof Number,
  isInt: t => Number.isInteger(t),
  isFloat: t => "number" == typeof t && !Number.isInteger(t),
  isBoolean: t => "boolean" == typeof t,
  isArray: t => Array.isArray(t),
  isFunction: t => "function" == typeof t,
  isObject: t => null !== t && "object" == typeof t,
  isNull: t => null === t,
  isUndefined: t => void 0 === t,
  isEmpty(t) {
    return this.isArray(t) || this.isString(t)
      ? 0 === t.length
      : !!this.isObject(t) && 0 === Object.getOwnPropertyNames(t).length;
  },
  is: {
    string: t => type.strict.string(t),
    number: t => type.strict.number(t),
    int: t => type.strict.int(t),
    float: t => type.strict.float(t),
    boolean: t => type.strict.boolean(t),
    array: t => type.strict.array(t),
    function: t => type.strict.function(t),
    object: t => type.strict.object(t),
    null: t => type.strict.null(t),
    undefined: t => type.strict.undefined(t)
  },
  strict: {
    errorMsg: "Strict type failed, needs to be ",
    number(t) {
      return this.typeOperator(t, "number");
    },
    int(t) {
      return this.typeOperator(t, "int");
    },
    float(t) {
      return this.typeOperator(t, "float");
    },
    string(t) {
      return this.typeOperator(t, "string");
    },
    boolean(t) {
      return this.typeOperator(t, "boolean");
    },
    array(t) {
      return this.typeOperator(t, "array");
    },
    function(t) {
      return this.typeOperator(t, "function");
    },
    object(t) {
      return this.typeOperator(t, "object");
    },
    null(t) {
      return this.typeOperator(t, "null");
    },
    undefined(t) {
      return this.typeOperator(t, "undefined");
    },
    typeOperator(t, e) {
      if (type[`is${e.charAt(0).toUpperCase() + e.slice(1)}`](t)) return t;
      throw new TypeError(this.errorMsg + e);
    }
  },
  make: {
    number: (t = -999999, e = 999999) => (
      type.is.number(t), type.is.number(e), t > e && (t = e), Math.random() * (t - e) + e
    ),
    int: (t = -999999, e = 999999) => (
      type.is.int(t), type.is.int(e), t > e && (t = e), Math.floor(Math.random() * (t - e + 1)) + e
    ),
    float(t = -999999, e = 999999) {
      type.is.number(t), type.is.number(e);
      const r = this.number(t, e);
      return type.isInt(r) ? r + 0.1 : r;
    },
    string(t = 3, e = 5) {
      return (
        type.is.int(t),
        type.is.int(e),
        t <= 0 && (t = 3),
        e <= 0 && (e = 3),
        t > e && (t = e),
        Math.random()
          .toString(36)
          .slice(2)
          .substr(0, this.int(t, e))
      );
    },
    stringLong(t = 7) {
      type.is.int(t), t <= 0 && (t = 7);
      let e = "";
      for (let r = 0; r < t && ((e += `${this.string(1, 8)} `), 9999 !== r); r++);
      return e.trim();
    },
    boolean: () => Math.random() >= 0.5,
    array(t, e) {
      return this.arrayRange(t, e);
    },
    arrayRange: (t = 0, e = 0) => (
      type.is.int(t),
      0 === e && ((e = t), (t = 0)),
      (t = parseInt(t, 10)),
      (e = parseInt(e, 10)),
      t > e && (t = e),
      Array(e - t + 1)
        .fill(0)
        .map((e, r) => r + t)
    ),
    random() {
      const t = Object.keys(this);
      return this[t[this.int(0, t.length)]]();
    }
  },
  list: {
    get numbers() {
      return [1, -1, 0, -0, 242, -242];
    },
    get ints() {
      return [1, -1, 0, 1, -1, -0];
    },
    get floats() {
      return [1.42, -1.42];
    },
    get strings() {
      return ["0", "-0", "1", "0", "1.242", "-1.422", "$#@*&(", "null", "undefined", "false"];
    },
    get functions() {
      return [
        function() {},
        function(t) {
          return (t = t || 2) > 0;
        }
      ];
    },
    get objects() {
      return [{}, { obj: 1 }];
    },
    get arrays() {
      return [[], ["array"]];
    },
    get booleans() {
      return [!1, !0];
    },
    get null() {
      return [null];
    },
    get undefined() {
      return [void 0];
    },
    get NaN() {
      return [NaN];
    },
    get specialVoids() {
      return [null, void 0, NaN];
    },
    allTypesExcept(...t) {
      const e = Object.assign({}, this);
      t.forEach(t => delete e[t]);
      let r = [];
      for (let t in e)
        if (e.hasOwnProperty(t) && "allTypesExcept" !== t) {
          const n = e[t];
          r = r.concat(n);
        }
      return r;
    }
  },
  report: {
    stat: [],
    showValidationReport(t) {
      const e = type.report.getReport(t, "purge");
      e.reportTotal === e.reportSuccess
        ? (console.log(
            `\nAll ${e.reportTotal} Input types validation is ok in scope '${type.getFunctionCallerName(2)}'`
          ),
          "errors-only" !== t && console.log(e.reportStr))
        : (console.log(
            `Test results for scope '${type.getFunctionCallerName(2)}' -- ${e.reportTotal}(${e.reportSuccess}/${
              e.reportFailed
            }) Total(Success/Failed)`
          ),
          console.log(e.reportStr));
    },
    addReport(t, e) {
      const r = { reportString: t, testResult: e };
      let n = type.report.stat.slice();
      n.push(r), (type.report.stat = n);
    },
    getReport(t, e) {
      let r,
        n = 0,
        o = 0,
        i = 0,
        p = type.report.stat.slice();
      return (
        p.length > 0 &&
          ((r = "\n----- Input types validation report. -----\n"),
          p.forEach(e => {
            "errors-only" === t ? 0 === e.testResult && (r += `${e.reportString}`) : (r += `${e.reportString}`),
              1 === e.testResult ? o++ : i++,
              n++;
          }),
          (r += "\n\n--------------------\n")),
        "purge" === e && (type.report.stat = []),
        { reportStr: r, reportTotal: n, reportSuccess: o, reportFailed: i }
      );
    },
    number: (t, e = "") => (
      type.isNumber(t)
        ? type.report.addReport(`\nINPUT OK -- Number: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Number: ${e} == ${t}`, 0),
      t
    ),
    string: (t, e = "") => (
      type.isString(t)
        ? type.report.addReport(`\nINPUT OK -- String: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a String: ${e} == ${t}`, 0),
      t
    ),
    boolean: (t, e = "") => (
      type.isBoolean(t)
        ? type.report.addReport(`\nINPUT OK -- Boolean: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Boolean: ${e} == ${t}`, 0),
      t
    ),
    array: (t, e = "") => (
      type.isArray(t)
        ? type.report.addReport(`\nINPUT OK -- Array: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Array: ${e} == ${t}`, 0),
      t
    ),
    function: (t, e = "") => (
      type.isFunction(t)
        ? type.report.addReport(`\nINPUT OK -- Function: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Function: ${e} == ${t}`, 0),
      t
    ),
    object: (t, e = "") => (
      type.isObject(t)
        ? type.report.addReport(`\nINPUT OK -- Object: ${e} == ${JSON.stringify(t)}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Object: ${e} == ${t}`, 0),
      t
    ),
    null: (t, e = "") => (
      type.isNull(t)
        ? type.report.addReport(`\nINPUT OK -- Null: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Null: ${e} == ${t}`, 0),
      t
    ),
    undefined: (t, e = "") => (
      type.isUndefined(t)
        ? type.report.addReport(`\nINPUT OK -- Undefined: ${e} == ${t}`, 1)
        : type.report.addReport(`\nINPUT IS NOT a Undefined: ${e} == ${t}`, 0),
      t
    )
  },
  getFunctionCallerName(t) {
    type.strict.number(t), (t = t || 1);
    let e = new Error().stack.match(/at (\S+)/g)[t].slice(3);
    return "new" === e && (e = new Error().stack.match(/at (\S+)/g)[t + 1].slice(3)), e;
  },
  getLevelExecutionErrorData(t) {
    type.strict.number(t);
    let e = "";
    for (let r = 0; r < t; r++) e += type.getFunctionCallerName(t);
    return e;
  }
};
module.exports = type;
